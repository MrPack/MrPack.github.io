<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Author Name,name@example.com"><title>Redis 持久化答疑 · 喵？喵？喵？</title><meta name="description" content="关于Redis 本身，一些同事对它的理解是一个内存服务，同时衍生了很多疑问：Redis本身如果进行crash掉，那么数据还在么？是否会丢失数据等问题。接下来针对这个问题简单讲解一下

Redis相关的实现。Redis 本身是一个全内存型数据库存储，区别于缓存服务，Redis本身管理和持久化着数据，基"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">喵？喵？喵？</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/http://weibo.com/maoerorz"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/https://github.com/MrPack"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page">

<div class="post animated fadeInDown"><div class="post-title"><h3><a>Redis 持久化答疑</a></h3></div><div class="post-content"><blockquote>
<p>关于Redis 本身，一些同事对它的理解是一个内存服务，同时衍生了很多疑问：Redis本身如果进行crash掉，那么数据还在么？是否会丢失数据等问题。接下来针对这个问题简单讲解一下</p>
</blockquote>
<h2 id="Redis相关的实现。"><a href="#Redis相关的实现。" class="headerlink" title="Redis相关的实现。"></a>Redis相关的实现。</h2><p>Redis 本身是一个全内存型数据库存储，区别于缓存服务，Redis本身管理和持久化着数据，基于RDB+AOF来进行数据的持久化管理，从而规避掉Redis进程crash掉的数据丢失问题。</p>
<h2 id="什么是RDB？"><a href="#什么是RDB？" class="headerlink" title="什么是RDB？"></a>什么是RDB？</h2><p>RDB是Redis在某个时候点把这一刻的内存镜像按照特点格式持久化磁盘。这一过程操作是比较重的，而Redis本身是单线程模型，所以Redis的解决方案是Fork一个进程进行RDB的dump操作，从而规避了阻塞主线程的问题，也规避掉了并发问题，从而简化了很多代码。但是也存在一些问题，由于Fork模型的问题，当Fork出一个进程的时候，子进程会继承父进程进程内存空间的数据，不过在fork之后，为了性能考虑操作系统不会直接copy一份完整内存副本，而是基于copyOnWrite的方式，当有进程对于某块内存空间进行更新的时候再触发数据的copy。如果当Redis的请求量比较大的时候，在做RDB dump的极端情况下，需要系统的内存支持当前节点 * 2的内存量。</p>
<h2 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF?"></a>什么是AOF?</h2><p>Redis提供服务的时候，如果这个时候有数据进行更新，这个时候Redis为了保证数据是可靠的，所以这个时候会写入到一个AOF (append of file)的内存buffer空间，然后定期追加到aof文件（可以指定策略，比如每写一条都写一次磁盘，或者指定多少秒，或者累计多少条更新，再刷新到磁盘，后面的在redis进程异常挂掉的情况下会丢失部分数据。aof功能也可以关掉，如果关掉的话，那么redis这个时候最好只用于作为cache）。</p>
<h2 id="进程crash掉如果恢复？"><a href="#进程crash掉如果恢复？" class="headerlink" title="进程crash掉如果恢复？"></a>进程crash掉如果恢复？</h2><p>在生成RDB的时候，在RDB头部记录了当时的AOF的记录点，然后当进程crash恢复的时候，开始加载恢复RDB，读取头部还原aof的记录点，然后回访所有的RDB记录，更新到内存，接着从aof的记录点，开始读取之后的aof的记录，然后进行回放，从而完成完整的数据。</p>
<h2 id="RDB-AOF什么场景下还会用到？"><a href="#RDB-AOF什么场景下还会用到？" class="headerlink" title="RDB + AOF什么场景下还会用到？"></a>RDB + AOF什么场景下还会用到？</h2><p>Redis本身支持主从同步，而它的全量主从同步就是基于RDB+AOF的方案，当有一个新的节点的时候，Redis slave向master发送sync的请求，然后Redis这个时候判断当前的RDB的情况，如果有RDB，那么把RDB同步给slave，如果没有RDB，那么触发RDB Dump，这个时候slave就一直等待相应的结果。然后slave接收完RDB的数据之后，开始重新reload RDB的时候，reload完成后，开始向master同步aof的增量数据。对于一个不是新的节点，一般走增量同步。</p>
<h2 id="RDB-回放的耗时？"><a href="#RDB-回放的耗时？" class="headerlink" title="RDB 回放的耗时？"></a>RDB 回放的耗时？</h2><p>取决于数据量和数据记录数，一般情况下，100GB的数据得回复个1小时左右。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-09-15</span><i class="fa fa-tag"></i><a href="/tags/redis/" title="redis" class="tag">redis </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://b.icodeall.com/2017/09/15/redis-persist/,喵？喵？喵？,Redis 持久化答疑,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2017/09/14/REDIS-I/" title="Redis介绍与应用优化_分享记录" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>